---
title: "Advanced indexing and index tricks"
date: 2020-07-31T15:37:05+08:00
categories: ["NumPy"]
tags: ["NumPy"]
draft: false
---

相对于常规Python序列，NumPy提供了更多的索引便利。其异同主要体现在如下两个方面：

+ 与Python序列相同的是，NumPy可以通过整型索引访问固定元素，也可以通过切片访问连续元素；
+ 与Python序列不同的是，ndarray可以被整型数组和布尔型数组索引，访问连续或不连续的元素。

## **以整型数组索引ndarray**

这种方式访问ndarray实例的元素，是将元素索引放在一个整型数组当中，然后以该数组为索引访问元素，最终便会得到元素集合。示例如下

```python
import numpy as np

a = np.random.default_rng(1).random((10,))
print(a)
i = np.array([1, 3, 5, 7])
print(a[i])
```

输出如下

```python
[0.51182162 0.9504637  0.14415961 0.94864945 0.31183145 0.42332645
 0.82770259 0.40919914 0.54959369 0.02755911]
[0.9504637  0.94864945 0.42332645 0.40919914]
```

上述索引我们将其包含在了ndarray实例中，如果直接使用Python数组可以吗？答案是肯定的。

上述示例虽然简单，但是不足以窥探以整型数组方式索引ndarray实例的真正行为。事实上，以整型数组方式索引ndarray的元素，永远都是作用在ndarray实例的第一个轴的元素上，且索引的最终ndarray构造取决于索引数组的构造，但是结果ndarray数组的结构却并不一定与索引数组的构造相同，只是大体上是一致的，这是因为被索引数组的第一个轴的元素的结构（维数）是不确定的。

### **多维数组索引一维数组**

首先以多维数组索引一维数组为例，解释其行为。

若索引数组为二维，那么最终的结果数组将是二维的，其本质仍然是以二维数组的整型元素索引一维数组的第一个轴的元素（自然也是标量）然后替换索引数组的当前索引作为值，所以最终是二维的。

但是这只是形式上的解释，这里并不是真正的“替换”，因为如果是替换的话，意味着并未产生拷贝，那么索引数组的元素发生变化自然会影响最终的结果数组，但是是事实并未产生影响，所以姑且以形式上的“替换”来解释这种行为。

示例代码如下

```python
import numpy as np

a = np.random.default_rng(1).random((10,))
print(a)    # 原ndarray实例
i = np.array([[3, 4], [9, 7]])
b = a[i]
print(b)    # 索引到的结果数组
i[0] = [1, 2]    # 索引数组发生变化
print(b)    # 索引到的结果数组仍未发生变化，证明二者不冲突
```

输出如下

```python
[0.51182162 0.9504637  0.14415961 0.94864945 0.31183145 0.42332645
 0.82770259 0.40919914 0.54959369 0.02755911]
[[0.94864945 0.31183145]
 [0.02755911 0.40919914]]
[[0.94864945 0.31183145]
 [0.02755911 0.40919914]]
```

### **多维数组索引多维数组**

上述已经将数组索引的行为解释的很清楚了。这里主要演示一下**当被索引数组为多维时，索引数组的整形索引值本质上是索引多维数组第一个轴的元素**。

不妨以NumPy官方的代码为例，如下

```python
import numpy as np

palette = np.array([[0, 0, 0],
                    [255, 0, 0],
                    [0, 255, 0],
                    [0, 0, 255],
                    [255, 255, 255]])
image = np.array([[0, 1, 2, 0],
                  [0, 3, 4, 0]])
print(palette[image])
```

输出为

```python
[[[  0   0   0]
  [255   0   0]
  [  0 255   0]
  [  0   0   0]]

 [[  0   0   0]
  [  0   0 255]
  [255 255 255]
  [  0   0   0]]]
```

答案不言而喻。上述结论明显得证。

### **多维索引**

上面我们看到的是索引数组虽然其本身可以是多维的，但是其作为索引本质上是一维的，因为它只索引被索引数组的一个维度。也就是本质上，上述代码的索引数组是这样写的

```python
print(a[(i)])
print(palette[(image)])
```

如果是多维索引呢？那么最多自然可以索引被索引数组的的全部维度。

以二维为例，通过二维索引索引被索引数组的全部两个维度

```python
import numpy as np

a = np.array(np.ceil(10 * np.random.default_rng(1).random((25,)))).reshape((5, 5))
print(a)
fd = np.array([[1, 3], [2, 4]])
sd = np.array([[0, 2], [1, 3]])
print(a[fd, sd])    # 本质上是a[(fd, sd)]
```

输出为

```python
[[ 6. 10.  2. 10.  4.]
 [ 5.  9.  5.  6.  1.]
 [ 8.  6.  4.  8.  4.]
 [ 5.  2.  5.  3.  3.]
 [ 8.  3.  5. 10. 10.]]
[[ 5.  5.]
 [ 6. 10.]]
```

首先，第一个维度的索引通过`fd`来指明，其索引第一个维度的指定行，即

```python
[ 5.  9.  5.  6.  1.], [ 5.  2.  5.  3.  3.], 
[ 8.  6.  4.  8.  4.], [ 8.  3.  5. 10. 10.]
```

然后在第一个维度的基础上，通过`sd`分别索引下一个维度，便可得到结果

```python
5.  5.
6. 10.
```

上面说了，`a[fd, sd]`等同于`a[(fd, sd)]`，但是不等同于`a[np.array(fd, sd)]`，因为后者的本质实际上等同于

```python
[[[1, 3], [2, 4]], [[0, 2], [1, 3]]]
```

从而会得到一个四维数组，明显不符合其动作要求。特别地，有可能会出现下标越界的错误。

我们也可以对数组进行赋值，一维数组和高维数组均可，只是方式不同。以一维数组为例，如下

```python
import numpy as np

a = np.arange(5)
a[[0,0,2]] = [1,2,3]
print(a)    # [2 1 3 3 4]
```

可以看到，若一个索引出现了不少于一次，那么以最后出现的索引对应的值为标准对其进行赋值。但是对于Python的`+=`运算符，即使相同索引出现若干次，那么也只会计算一次。

## **以布尔数组索引ndarray**

以布尔数组索引ndarray的本质就是将满足条件的元素筛选出来。由于满足条件的元素并不一定成结构排列，因此这种方式最终提取出的结果为一维数组。示例如下

```python
import numpy as np

a = np.array(np.ceil(10 * np.random.default_rng(1).random((25,)))).reshape((5, 5))
b = a > 5
print(a)
print(b)
print(a[b])
```

输出为

```python
[[ 6. 10.  2. 10.  4.]
 [ 5.  9.  5.  6.  1.]
 [ 8.  6.  4.  8.  4.]
 [ 5.  2.  5.  3.  3.]
 [ 8.  3.  5. 10. 10.]]
[[ True  True False  True False]
 [False  True False  True False]
 [ True  True False  True False]
 [False False False False False]
 [ True False False  True  True]]
[ 6. 10. 10.  9.  6.  8.  6.  8.  8. 10. 10.]
```

可见，将为`true`的数组元素均提取了出来。

当然也可以对其进行赋值，如下

```python
import numpy as np

a = np.array(np.ceil(10 * np.random.default_rng(1).random((25,)))).reshape((5, 5))
b = a > 5
print(a)
print(b)
a[b] = -1
print(a)
```

输出如下

```python
[[ 6. 10.  2. 10.  4.]
 [ 5.  9.  5.  6.  1.]
 [ 8.  6.  4.  8.  4.]
 [ 5.  2.  5.  3.  3.]
 [ 8.  3.  5. 10. 10.]]
[[ True  True False  True False]
 [False  True False  True False]
 [ True  True False  True False]
 [False False False False False]
 [ True False False  True  True]]
[[-1. -1.  2. -1.  4.]
 [ 5. -1.  5. -1.  1.]
 [-1. -1.  4. -1.  4.]
 [ 5.  2.  5.  3.  3.]
 [-1.  3.  5. -1. -1.]]
```

还有一种以布尔数组索引ndarray的方式，其本质上与以整型数组索引ndarray类似。比如下述索引长度为5的一维数组的索引为`0, 1, 3`的元素。

```python
import numpy as np

a = np.array(np.ceil(10 * np.random.default_rng(1).random((5,))))
print(a)    # [ 6. 10.  2. 10.  4.]
print(a[[True, True, False, True, False]])    # [ 6. 10. 10.]
```

不再赘述。