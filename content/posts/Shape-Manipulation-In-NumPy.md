---
title: "Shape manipulation in NumPy"
date: 2020-07-26T12:16:05+08:00
categories: ["NumPy"]
tags: ["NumPy"]
draft: false
---

NumPy中，已定义好的数组可以重新调整维度，但是调整后的维度包含的元素数目应该与调整之前的相同。

## **改变数组的结构**

NumPy中改变数组结构的方式大体包含三种，一种是维度“压缩”后的数组，其本质是逐元素按行将数组组织成一个一维数组，方法为`ndarray.ravel()`；一种是数组转置；另一种是元素数目相同基础之上的尺寸调整。以下三部分分别基于下述代码

```python
import numpy as np

ram = np.random.default_rng(1)
a = np.ceil(10 * ram.random((4, 4), np.float64), dtype = np.float64)
```

### **数组扁平化**

对$n$维数组进行扁平化操作（$n \ge 2$），其本质就是逐元素按行组织数组元素为一个一维数组，直接调用ndarray的ravel方法即可，如下

```python
a.ravel()
```

该方法并不会在原数组上进行操作，所以想要复用其运算结果，必须开辟内存地址存储之。

### **数组转置**

这个相当好理解，方法为调用ndarray的T属性即可实现转置，如下

```python
a.T
```

该方法同样不会在原数组上进行修改，若想复用其运算结果，仍然需要变量存储。

### **数组维度调整**

另一种调整数组维度的办法就是调整其尺寸，有两个方法，如下

+ `ndarray.reshape()`，该方法接受一个元组，该元组为新数组的尺寸信息，该方法不会在原数组上进行操作；
+ `ndarray.resize()`，该方法接受一个元组，该元组为新数组的尺寸信息，该方法会在原数组上进行操作。

若原数组的尺寸信息可以通过元组`t1`表示，新数组的尺寸信息可以通过`t2`表示，那么`t1`诸元素之积应该等于`t2`诸元素之积，即下述代码中`r1 == r2`。

```python
r1 = 1
r2 = 1
for t in t1:
    r1 *= t
for t in t2:
    r2 *= t
print(r1 == r2)    # True
```

## **合并数组的几种方式**

### **垂直合并与水平合并**

几个尺寸相同的数组可以通过不同的轴实现合并，有两种合并方式，一种是垂直合并，另一种是水平合并。

对于含有$n$个轴的（$n$维）数组（$n \ge 2$），垂直合并首先创建一个$n$维数组，确保最终的结果数组与被合并数组的维数一致，然后逐个将被合并数组的第一个轴的元素（$n - 1$维）作为结果数组第一个轴的元素（$n - 1$维）加入其中。通过调用`np.vstack()`即可实现，其参数为要合并的数组的元组。对于垂直合并，合并后返回数组的第一轴的长度将是被合并数组第一轴的长度之和。示例如下

```python
import numpy as np

ram = np.random.default_rng(1)
a = np.ceil(10 * ram.random((2, 2, 2), np.float64), dtype = np.float64)
print(a)
b = np.ceil(10 * ram.random((2, 2, 2), np.float64), dtype = np.float64)
print(b)
print('after stacking : ')
print(np.vstack((a, b)))
```

输出为

```python
[[[ 6. 10.]
  [ 2. 10.]]

 [[ 4.  5.]
  [ 9.  5.]]]
[[[6. 1.]
  [8. 6.]]

 [[4. 8.]
  [4. 5.]]]
after stacking : 
[[[ 6. 10.]
  [ 2. 10.]]

 [[ 4.  5.]
  [ 9.  5.]]

 [[ 6.  1.]
  [ 8.  6.]]

 [[ 4.  8.]
  [ 4.  5.]]]
```

对于含有$n$个轴的（$n$维）数组（$n \ge 2$），水平合并也是首先创建一个$n$维数组，然后将被合并数组的第二个轴的元素（$n - 2$维）拼接起来然后将其包装在一个数组中，这个数组就变成了$n-1$维，然后就可以作为$n$维结果数组的元素加入其中。通过调用`np.hstack()`即可实现，其参数为要合并的数组的元组。那么合并后的结果数组第一轴的长度将会保持不变，但是第二轴的长度将会变成若干个被合并数组第二轴长度之和。示例如下

```python
import numpy as np

ram = np.random.default_rng(1)
a = np.ceil(10 * ram.random((2, 2, 2), np.float64), dtype = np.float64)
print(a)
b = np.ceil(10 * ram.random((2, 2, 2), np.float64), dtype = np.float64)
print(b)
print('after stacking : ')
print(np.hstack((a, b)))
```

输出为

```python
[[[ 6. 10.]
  [ 2. 10.]]

 [[ 4.  5.]
  [ 9.  5.]]]
[[[6. 1.]
  [8. 6.]]

 [[4. 8.]
  [4. 5.]]]
after stacking : 
[[[ 6. 10.]
  [ 2. 10.]
  [ 6.  1.]
  [ 8.  6.]]

 [[ 4.  5.]
  [ 9.  5.]
  [ 4.  8.]
  [ 4.  5.]]]
```

### **column_stack与row_stack函数**

上述对垂直合并与水平合并的解释，附加了一个前提，即$n \ge 2$。但是如果$n = 1$呢？上述的解释就不适用了，因为不存在-1维。

一维数组同样可以进行垂直合并与水平合并，对应的函数分别为

+ `np.column_stack()`，该函数实现列合并，它会将相同长度的待合并一维数组的同一列组织为一行；
+ `np.row_stack()`，该函数实现行合并，它会将相同长度的待合并一维数组的行作为最终结果二维数组的单独一行。

对于相同顺序的尺寸相同的待合并一维数组，其行合并结果与列合并结果互为转置。示例如下

```python
import numpy as np

ram = np.random.default_rng(1)
a = np.array([1, 2])
b = np.array([3, 4])
c = np.array([5, 6])
print(np.column_stack((a, b, c)))
print(np.row_stack((a, b, c)))
print(np.column_stack((a, b, c)) == np.row_stack((a, b, c)).T)
```

结果如下

```python
[[1 3 5]
 [2 4 6]]
[[1 2]
 [3 4]
 [5 6]]
 [[ True  True  True]
 [ True  True  True]]
```

### **_r和_c**

`-r`可以将若干个长度相同或者不同的一维数组组织为一个一维数组，而`_c`则是将若干个长度相同的一维数组按列组织为一个二维数组，其中第二维的长度为长度相同的一维数组个数。示例如下

```python
import numpy as np

a = np.r_[1:4, 0, 3]
b = np.c_[1:4,0:3,4:7]
print(a)
print(b)
```

输出如下

```python
[1 2 3 0 3]
[[1 0 4]
 [2 1 5]
 [3 2 6]]
```

## **拆分数组**

既然可以如上述合并数组，那么也可以拆分数组。主要使用到的函数为`hsplit()`与`vsplit()`。以下解释如果不特别说明，那么只涉及对一维和二维数组的操作

+ `hsplit()`函数，该函数按水平方向将数组拆分为若干个同维度数组。其接受两个参数，第一个为待拆分的数组，第二个参数如果是一个整数那么代表将数组等分得个数，如果是一个元组，那么就会将元组当作拆分数组的索引。
+ `vsplit()`函数，该函数按垂直方向将数组拆分为若干个同维度数组，且只能施加在二维或者更高维度的数组上。第一个为待拆分的数组，第二个参数为一个元组，表示将从第几个索引处开始对其进行拆分。

```python
import numpy as np

print(np.hsplit(np.r_[1:4, 0, 3], 5))
print(np.hsplit(np.array([[1, 2, 3, 4], [5, 6, 7, 8]]), 2))
print(np.hsplit(np.array([[1, 2, 3, 4, 5, 6], [5, 6, 7, 8, 9, 0]]), (2, 3)))
print('-' * 10)
print(np.vsplit(np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]), 1))
print(np.vsplit(np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]), (1, 2)))
```

输出如下

```python
[array([1]), array([2]), array([3]), array([0]), array([3])]
[array([[1, 2],
       [5, 6]]), array([[3, 4],
       [7, 8]])]
[array([[1, 2],
       [5, 6]]), array([[3],
       [7]]), array([[4, 5, 6],
       [8, 9, 0]])]
----------
[array([[ 1,  2,  3,  4],
       [ 5,  6,  7,  8],
       [ 9, 10, 11, 12]])]
[array([[1, 2, 3, 4]]), array([[5, 6, 7, 8]]), array([[ 9, 10, 11, 12]])]
```